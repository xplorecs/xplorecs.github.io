<html>
  
<!-- Mirrored from xplorecs.org/project1 by HTTrack Website Copier/3.x [XR&CO'2014], Fri, 26 Aug 2022 17:10:23 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=utf-8" /><!-- /Added by HTTrack -->
<head>
    <title>
cs1120: Introduction to Computing - Explorations in Language, Logic, and Machines
</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    
    <link href='https://fonts.googleapis.com/css?family=Open+Sans:150,150italic,300italic,300,700' rel='stylesheet' type='text/css'>
    <link href="static/css/bootstrap.min.css" rel="stylesheet">
    <link href="static/css/styles.css" rel="stylesheet">
    <link rel="icon" type="image/ico" href="static/images/icon.jpg"/>
    
    
   <link href="static/css/shCoreDefault.css" rel="stylesheet">
   <script type="text/javascript" src="static/js/shCore.js"></script>
   <script type="text/javascript" src="static/js/shBrushPython.js"></script>
   <script type="text/javascript">
      SyntaxHighlighter.defaults['toolbar'] = false;
      SyntaxHighlighter.defaults['gutter'] = false;
      SyntaxHighlighter.all();
   </script>

  </head>
  <body>
    <div id="header">
<A href="index.html">cs1120: Introduction to Computing</a> &emsp;&emsp;&emsp;
<!-- Menu | Classes | Notes
<span class="right"><a href="/users/login">Login</a></span>
-->

</div>
    <div class="container">
    <div id="content">

<h1>Project 1: Making Mosaics</h1>
<p><div class="turnin"> 
<strong>Deliverable:</strong> Bring in to class on <strong>Friday, 5 February</strong> a stapled
turn-in containing your written and printed answers to Questions 1-5.
Please write your UVA ID (e.g., mst3k) in <b>big block letters</b> at
the top of your submission.<br />
   </div></p>
<h3>Collaboration Policy - Read Carefully</h3>
<p>For this assignment, you may discuss the assignment with anyone you want
and get help from others, so long as it is help in the spirit of
learning how to do things yourself not getting answers you don't
understand.  You should understand everything you turn in for the
assignment well enough to be able to produce it completely on your own.</p>
<p>Remember to follow the <a href="pledge.html">course pledge</a> you read and signed at
the beginning of the semester.  For this assignment, you may consult any
outside resources, including books, papers, web sites and people, you
wish <i>except</i> for materials from previous cs1120 courses.  You may
consult an outside person (e.g., another friend who is a CS major but is
not in this class) who is not a member of the course staff, but that
person cannot type anything in for you and all work must remain your own
and outside sources should never give you specific answers to problem
set questions.  </p>
<p>If you use resources other than the class materials, lectures and course
staff, you should document this in your turn-in.</p>
<p>You are <b>strongly encouraged</b> to take advantage of the scheduled
 help hours and office hours for this course.</p>
<h2>Purpose</h2>
<ul>
<li>Introduce <em>divide-and-conquer</em> problem solving.</li>
<li>Provide exposure to recursive definitions and functions as parameters.</li>
<li>Provide experience reading a Python program.</li>
<li>Learn to use and create functions.</li>
<li>Gain familiarity with the Python programming environment and programming language.</li>
<li>Make a delightful picture!</li>
</ul>
<p><div class=warning>
<strong>Warning:</strong> This problem set is different from typical assignments.  It
touches on lots of new concepts, but you are not expected to understand
everything in this assignment yet.  It is recommended that you skim
through the whole problem set before trying to answer the questions so
you have a clear idea on what you need to do.  You should attempt to
understand as much of the rest as possible, but don't worry if it
doesn't all make sense yet.  We won't cover everything you need to
understand all the provided code until near the end of the course.<br />
   </div></p>
<h2>Background</h2>
<p><a href="http://commons.wikimedia.org/wiki/File:Mosaico_Pez_Casa_Anfiteatro_MÃ©rida.jpg">
<img align=right src="static/images/fish-mosaic.jpg" width=268 height=175>
</a></p>
<p>A mosaic is a picture made up of lots of smaller pieces.  The ancient
Babylonians constructed elaborate mosaics using colored tiles.  A
<em>photo</em>mosaic is a mosaic, except instead of using single color
tiles for the tiles, it uses photographs.  For some example
photomosaics, see <a href="http://www.photomosaic.com/portfolio.html">
<em>http://www.photomosaic.com/portfolio.html</em></a>.</p>
<p>Making a photomosaic is a big task.  The way computer scientists (and
most other people) solve big problems is to break them into a few
smaller sub-problems whose solutions can be combined to solve the
original problem. This approach is sometimes called
<em>divide-and-conquer</em>.</p>
<p>Note that for a big problem like making a photomosaic, doing this once
is probably not enough.  The sub-problems are still too big to solve
easily.  So, we need to use divide-and-conquer again to break each
sub-problem into several sub-sub-problems.  We do this recursively,
until we get to sub-sub-sub-...-sub problems that are small enough that
we can solve them easily.</p>
<p>We can describe this process with <em>pseudocode</em> (that is, not
necessarily real Python code, but made to look like it):</p>
<p class="breakhere"></p>

<pre class="brush: python;">
def solve_big_problem(problem):
   if easy_to_solve(problem):                              # if it's easy
      return solve(problem)                                #   just solve it now!
   else:                                                   # otherwise 
      sub_problems = divide_problem(problem)               #   divide it into sub problems
      sub_solutions = map(solve_big_problem, sub_problems) #   solve each sub problem
      return combine_solutions(sub_solutions)              #   combine the partial solutions
</pre>

<p>Here, <code class="python functions">map</code> is a function that
applies another function to every item in a list.  The <code
class="python">divide_problem(problem)</code> evaluates to a list of
sub-problems.  The value of <code class="python">map(solve_big_problem,
sub_problems)</code> is the result of applying <code class="python">solve_big_problem</code>
to every sub-problem in that list.</p>
<p>Implementing <code class="python">solve</code>, <code
class="python">combine_solutions</code> and <code
class="python">divide_problem</code> for a real problem is the difficult
part.  There is a real art to figuring out how to divide a big problem
into a suitable set of smaller problems.  Being able to do this well is
the main thing that separates good problem solvers from mediocre ones.</p>
<h3>Python Expressions</h3>

<p><div class=q>
<strong>Question 1:</strong> For this question you should <strong>not</strong> use a Python interpreter.  For
each of the fragments, either: </p>
<ul>
<li>Explain why the fragment is not a valid Python expression; or,</li>
<li>Predict what value the expression will evaluate to.</li>
</ul>
<p>(Note that some of these fragments use things you have not seen yet, or
that test the corners of meaning that may not have been defined
completely.  Its okay if your prediction is wrong, so long as it is
thoughtful.)
   </div></p>
<ol type=a>
<li> <pre class="brush: python;">1120</pre>
<li> <pre class="brush: python;">70 + 80</pre>
<li> <pre class="brush: python;">+</pre>
<li> <pre class="brush: python;">3 > 2</pre>
<li> <pre class="brush: python;">(3 > 2) and (4 > 5)</pre>
<li> <pre class="brush: python;">if (12 > 10): 
    "good move" 
else:
    "try again"</pre>
<li> <pre class="brush: python;">if not "cookies": 
    "eat" 
else:
    "starve"</pre> 
<li> <pre class="brush: python;">if (10 > 11): +</pre>
</ol>

<h2>Getting Started Programming</h2>
<p>Before continuing with this assignment, you need to set up your own
programming environment, following the directions below.</p>
<h4>Python</h4>
<p>For the programming you do on your own machine, you will use the Python
3 programming language.  Python 3 is mostly similar to the Python 2
language used in the Udacity course, but has some important differences
(which will mostly not be apparent) as well as a few annoying
incompatibilities (which will be frustrating).  We will talk in class
about the differences and the reasons for the two versions.</p>
<p>For now, the most important difference you will encounter is the <code>print</code>
statement.  In Python 2, you can print something by doing, <code>print
"Hello!"</code>.  But, in Python 3, <code>print</code> is just like any other function
call.  So, it is necessary to pass the parameters to it using
parentheses: <code>print("Hello!")</code>.  (Yes, this is very annoying.  For now,
accept that there are semi-reasonable reasons why the Udacity class uses
Python 2, and why you will use Python 3 for programming on your own
machine, and why the languages are not compatible!)</p>
<p><strong>Download.</strong> Download the python interpreter and development
  environment from <a href="https://www.python.org/">https://www.python.org/</a>.
  On the drop-down menu, "Downloads", you should see "Download for
  Windows" or "Download for Mac OS X" and select "Python 3.5.1" to begin
  downloading.  (The python website is smart enough to identify the type
  of machine you are connecting from and give you the right version to
  download.  If you want more control, you can see all the different
  download files at
  <a href="https://www.python.org/downloads/release/python-351/">https://www.python.org/downloads/release/python-351/</a>.)</p>
<p>After the download completes, click on the file to open it and run the
  executable to install python (following the directions in the dialog
  boxes to complete the installation).</p>
<p><strong>Running Python.</strong> When this is finished, you will have a python
  interpreter and development environment installed on your system.  In
  your start menu, you will see the python 3.5 folder and "IDLE"
  file. You may start your python programming environment by clicking on
  "IDLE".</p>
<p><center>
<img alt="python" src="https://googledrive.com/host/0ByMwiqJ0uRtmTWFUZ1piRVF4b1U/1.png" />
   </center></p>
<p>Then you are able to input and execute Python code directly in the
python shell.</p>
<p>You can also create a source code file (select the File menu | New).
You can run the file you are editing by clicking "Run Module" on
drop-down menuâ "Run", or use the "F5" shortcut.</p>
<p><center>
<img alt="python" src="https://googledrive.com/host/0ByMwiqJ0uRtmTWFUZ1piRVF4b1U/2.png" />
   </center></p>
<p>Play around in your Python environment and get comfortable typing and running code.</p>
<p><div class=q> 
<strong>Question 2:</strong> Try evaluating all the fragments from Question 1 in turn
using the Python interpreter.  If any expression evaluates to
something different from what you expected in Question 1, figure out why
(you may need to play around with evaluating other expressions to do
this).  Don't change your answers to Question 1, but instead write down
explanations of why you think Python produces the value it does instead
of what you expected. (You don't lose any points on Question 1 or 2 if
your answers are wrong, but you must fully attempt the questions.) You
don't have to write anything down for the parts you predicted correctly.
   </div></p>
<h4>Version Control Systems</h4>
<p>A <em>version control system</em> provides a way to manage files and keep track
of changes.  This is especially important for programming since it is
often important to be able to compare different versions of the code,
and to be able to go back to an old version if something is broken.  The
other thing version control systems enable is for multiple people to
work together on a project well.  We will use a version control system
called <a href="https://git-scm.com/">git</a>.</p>
<p>A repository stores all the information about a project including both
the latest version of the files, and all the previous versions (or
enough information to reconstruct them as needed).  </p>
<p>We will use bitbucket to manage repositories in this class.  </p>
<p><strong>Sign up for a bitbucket account.</strong> Visit
  <a href="https://bitbucket.org/"><em>https://bitbucket.org/</em></a> and sign up for a
  free account.</p>
<p><strong>Download and install SourceTree.</strong> <em>SourceTree</em> is a convenient tool
  that makes it easier to manage repositories.  Visit
  <a href="https://www.sourcetreeapp.com/"><em>https://www.sourcetreeapp.com/</em></a> to
  download SourceTree, and follow the directions there to install it.</p>
<h4>Forking the Project 1 Repository</h4>
<p>Now you are ready to get to work!</p>
<p><strong>Fork Project 1.</strong> First, you will create a new repository in your account by <em>forking</em> the
provided Project 1 repository.  To do this, visit
<a href="https://bitbucket.org/cs1120/project1/fork">https://bitbucket.org/cs1120/project1/fork</a>.
You should check the "This is a private repository" box to make your
repository private (only visible to yourself and people you authorize to
access it).</p>
<p><strong>Clone to your machine.</strong> After you've forked the repository, you will
see it in your bitbucket account, but to edit the files you also want a
copy on your own machine.  To have a working copy of the repository on
your machine, clone in in SourceTree.  Select <code>File |
New/Clone</code> and enter the URL of the cloned repository. You can
copy this from the project page you see in bitbucket.org afer forking
the provided Project 1 repository.  It should be a URL like
<code>https://&lt;your bitbucket id&gt;@bitbucket.org/&lt;your bitbucket
id&gt;/project1.git</code>.</p>
<p>After this, you should see your own copy of the Project 1 files in the
selected directory.</p>
<p>The cloned repository contains these files:</p>
<ul>
<li><code>turnin.py</code> - This is the file you will edit and turn in (as a printout) for this assignment.</li>
<li><code>mosaic.py</code> - Python code for producing photomosaics. You do not need to edit this file (but are encouraged to look at it).</li>
<li><code>graphics.py</code> - Python code for manipulating images and
drawing on the screen. You do not need to edit or even look at this file.</li>
<li><code>get_images.py</code> - Python code for obtaining tile images using the Flickr API.</li>
<li><code>rotunda.gif</code> - A picture of UVA's Rotunda that we will use as our master image for the photomosaic.</li>
</ul>
<p>You should be able to find these files on your own machine now, and view
them in the Python editor.  Take a look at <code>mosaic.py</code> (but don't worry
if you don't understand much of the code in that file).  The only file
you will need to change for this assignment is <code>turnin.py</code>.</p>
<h4>Making Commits</h4>
<p>You can now edit files in that directory.  Start by editing the file
<code>turnin.py</code>, which is the file you will print out and submit for Project
1.  Near the top of this file you will find the lines: (note that they
are inside a triple quote, which is a common way of putting
specially-interpreted comments in Python files)</p>
<p><div class="indented">
<pre>
My name:    [replace with your name]
My UVA ID:  [replace with your ID]
</pre>
   </div></p>
<p>Replace the bracketed text with your name and UVA ID respectively.</p>
<p>After you've made the changes and saved the file, in SourceTree you should see something like this:</p>
<p><img align=center src="static/images/docommit.png" width=700></p>
<p>On the right side, you see the changes to the file (from the old version
in red, to the new version in green).</p>
<p>In the "Unstaged files" box, you see the files that have changed but
have not been committed to the repository.  This should only list one
file now: <code>turnin.py</code>.  Check the box next to it, which should should
move it to the "Staged files" area.</p>
<p>Click "Commit" (at the top left) to commit the changes.  You will get a
window to enter a commit message.  Enter something that explains the
change (e.g., "Entered my name and id").  Also, check the "Push changes
immediately to origin/master" box (this means your changes will also be
stored in the bitbucket copy of the repository).  Then, click "Commit"
to execute the commit.</p>
<h2>Photomosaics</h2>
<p>A (not too brilliant) kindergartner could follow these directions to 
make a photomosaic:</p>
<ol>
<li>Collect pictures to use as the tiles
<ol type=a>
<li>Ask your parents for some old magazines and scissors.  (<em>Note: it
is important that you let your parents know you will cut up the
magazines!</em>)
<li>Repeat many times until you have enough pictures:
<ol type=i>
<li>Pick one of the magazines.
<li>Look through it until you find a good picture.  A good picture is
pretty small and colorful.
<li>Cut out the picture using the scissors.
</ol>
</ol>
<li>Break for milk and cookies.
<li>Find a really big picture you want to use as the master for the
photomosaic.
<li>Put a thin piece of tracing paper on top of the master picture.
<li>Draw a grid on the tracing paper:
<ol type=a>
<li>Get a ruler and crayon.
<li>Repeat until the whole paper is covered with lines, starting at the
left edge:
<ol type=i>
<li>Line up the ruler parallel (<em>Note: you might have to explain what
this means to the kindergartener, but you can always give her a copy of
<a href="http://en.wikipedia.org/wiki/Euclid%27s_Elements">Euclid's Elements</a></em>) to the long edge of the paper.
<li>Draw a line using the ruler.
<li>Move the ruler a little bit to the right.
</ol>
<li>Repeat until the whole paper is covered with lines, starting at the
top:
<ol type=i> 
<li>Line up the ruler parallel to the top edge of the paper.
<li>Draw a line using the ruler.
<li>Move the ruler a little bit down the page.
</ol>
</ol>
<li>Naptime.
<li>Put on the tiles:
<ol type=a>
<li>For each rectangle on the grid that you drew on the tracing paper:
<ol type=i>
<li>Look through the tile pictures to find one that best matches the
color on the master picture under that rectangle.
<li>Glue that tile picture onto the rectangle.
</ol>
</ol>
<li>Clean up the glue you spilled on the floor before adults get home.
</ol>

<p>We will create a photomosaic using Python in almost the same way &#151;
except the computer is much dumber than our kindergartener, so we need
to break the steps into even smaller problems before it can perform
them.  (Our computer won't need to break for milk and cookies, but it will
need to collect garbage.)</p>
<p>In step 7.a.i. the kindergartner has to look through the tile pictures
to find one that <em>best matches the color on the master picture under
that rectangle</em>.  Your task for this problem set will be to define a
function that does that.</p>
<p>First, we explain how the rest of the photomosaic program works.  We
show lots of code here, but <b>don't worry</b> if you don't understand all of
it.  You should attempt to understand how it works, but it is not
necessary to completely understand all the code shown here to complete
this assignment. </p>
<h3>Creating a Photomosaic</h3>
<p>We can divide the photomosaic problem into three big steps:
<ol>
<li> Get images for the tiles and master.
<li> Select the tile images that best match the colors on the master.
<li> Display the tile images.
</ol></p>
<p>First, we provide some background on images.  Then we solve step 2
first, and then steps 1 and 3.  Often, it is easier to solve a problem
by considering the sub-problems out of order.</p>
<h3>Color</h3>
<p>All colors can be created by mixing different amounts of red, green and
blue light &#151; if you look closely at a television or computer
monitor, you will see the whole image is made up of red, green and blue
dots.  We can represent a color using three numbers representing how
much red, green and blue is in the pixel.  For most computer images,
there are a limited number of colors.  In the images we will use, there
are 256 different intensity values for each color.  Hence, we can
represent a color using three values between 0 and 255 to represent the
amount of red, green, and blue in a pixel.  <p> For example, <tt>[0, 0,
0]</tt> is black, <tt>[255, 255, 255]</tt> is white, <tt>[255, 0,
0]</tt> is red, <tt>[0, 0, 255]</tt> is blue, and <tt>[255, 255, 0]</tt>
is yellow (mixing red and green light makes yellow).  <p></p>
<p>The provided file <code>mosaic.py</code> defines some procedures for manipulating colors:</p>
<ul>
<li><code class="python">make_color(<em>red</em>,<em>green</em>,<em>blue</em>)</code> &#151;
evaluates to a color with red, green and blue components given by the
parameters.  The color values are between 0 and 255.  For example,
<code class="python">make_color(255,0,0)</code> is the color red.

<li><code class="python">get_red(<em>color</em>)</code> &#151; evaluates to the red component
of the color parameter.  For example, <code class="python">get_red(make_color(255,0,0))</code>
returns <code class="python">255</code>. 

<li><code class="python">get_green(<em>color</em>)</code> &#151; evaluates to the green component
of the color parameter. 

<li><code class="python">get_blue(<em>color</em>)</code> &#151; evaluates to the blue component
of the color parameter. 

<li><code class="python">show_color(<em>color</em>)</code> &#151; pops up a window that
displays a circle of the color passed as its parameter.
</ul>

<p>The file <code>mosaic.py</code> also defines some common colors:
<pre class="brush: python;">
WHITE = make_color(255, 255, 255)
BLACK = make_color(0, 0, 0)
RED = make_color(255, 0, 0)
GREEN = make_color(0, 255, 0)
BLUE = make_color(0, 0, 255)
YELLOW = make_color(255, 255, 0)
PURPLE = make_color(102, 51, 153)
</pre></p>
<p>Try evaluating <code class="python">show_color(YELLOW)</code>. You
should see a small window appear containing a yellow circle.</p>
<p class="breakhere"></p>

<p><div class=q>
<b>Question 3:</b> Define a new color <code class="python">ORANGE</code>
that looks like orange.  Your definition should be similar to the ones
above, but with different numbers (if you have trouble finding numbers that look like orange, try <a href="http://www.colorpicker.com/">http://www.colorpicker.com/</a>.)  Use <code
class="python">show_color(ORANGE)</code> to display your color.
   </div></p>
<p>We can say color 1 is <em>brighter</em> than color 2 if the sum of the
red, green and blue values of color 1 is greater than the sum of the
red, green and blue values of color 2.  This may not correspond
exactly to our intuitive perception of colors, but it should be pretty
close.</p>
<p><div class=q>
<b>Question 4:</b> 
Define a procedure <code class="python">is_brighter</code> that takes two colors as
parameters and returns <code class="python">True</code> if the first color is
brighter than the second color; otherwise, it returns <code class="python">False</code>.
   </div></p>
<p>Your procedure might start out like this:
<pre class="brush: python;">
def is_brighter(color1, color2): 
    # Fill in code here that determines if color1 is brighter than
    # color2. A good definition will need only a few lines of code.
    # Your procedure should always return either True or False.
</pre></p>
<p>Hint: you may want to use provided functions such as <code
class="python">get_red</code>, and don't forget to <code class="python">return</code> the
answer!</p>
<p>Test your procedure by evaluating it with several different parameters.
For example, you should get these results:</p>
<pre class="brush: python;">
>>> is_brighter(WHITE, RED)
True
>>> is_brighter(RED, WHITE)
False
>>> is_brighter(RED, RED) 
False   # red is as bright as red, but NOT brighter
>>> is_brighter(RED, BLUE) 
False
>>> is_brighter(YELLOW, RED) 
True 
</pre>

<h2>Images</h2>
<p>A computer represents an image by a <em>bitmap</em>.  A bitmap is a
two-dimensional array of picture elements (<em>pixels</em>).  Each pixel
is just one dot of color.  A bitmap is actually a <em>dot</em>-mosaic,
where the tiles are individual colored dots.</p>
<p>Instead of storing images as bitmaps, we usually store them using a
compressed format such as a <tt>GIF</tt> or a <tt>JPG</tt>.  Compressed
images take up less memory on the disk or to download, but are harder to
manipulate.  Fortunately, there are many libraries that provide
functions for converting them to bitmaps so you don't need to worry
about it.  We can store our images in compressed formats and use these
library functions to convert them into bitmaps when we use them in our
photomosaic program.</p>
<p>The pixels in a bitmap are numbered on a grid.  The top left corner is
(0, 0).  If the bitmap is <em>w</em> pixels wide and <em>h</em> pixels
high, the bottom right corner is (<em>w</em> - 1, <em>h</em> - 1).</p>
<h3>Obtaining Tile Images</h3>
<p>The <code>get_images.py</code> file contains a program for obtaining tile images.
One of the things that makes it possible to write interesting programs
without an excessive amount of effort is that programs can take
advantage of other programs.  Here, we take advantage of a web service
provided by the image-hosting site Flickr.  The <a href="https://www.flickr.com/services/api/">Flick
API</a> provides a way for a program
to obtain images that people have uploaded to Flickr.</p>
<p>We can do that in a python program just by sending a web request to 
<em>https://api.flickr.com/services/rest/</em> with the right parameters.</p>
<p>To use this, the requests package needs to be installed on your machine.
To install it, simply execute this command in a command shell (Terminal
on Mac OS X or CMD in Windows):</p>
<p><code>pip install requests</code></p>
<p>The <code>pip</code> command can be used to install new libraries to use in your
Python programs.  For processing the images, we also need an image
library called Pillow:</p>
<p><code>pip install Pillow</code></p>
<p>You don't need to understand the code in <code>get_images.py</code> for this
assignment, but can run it from the command shell (or Terminal in Mac OS
X) like this to obtain tile images to use for your photomosaic (but
replace the <search_text> with a keyword you want to use for your image
tiles search):</p>
<p><code>python get_images.py -d tiles -l 300 &lt;search_text&gt;</code></p>
<p>(Note: in Windows, you may need to do <code>py</code> instead of <code>python</code>:
<code>py get_images.py -d tiles -l 100 cat</code>
)</p>
<p>This will search Flickr for 300 images that match your search text, and
store small versions of those images in the <code>tiles</code> directory.</p>
<h3>Selecting Tiles</h3>
<p>To select tile images for our photomosaic we follow steps 5 through 7
from the kindergartener description.  We don't need to worry about
programming step 6 (naptime), but do make sure to take breaks if you get
frustrated (and even if you don't, its never a good idea to sit down or
look at a screen for too long).</p>
<p>To find a tile image that matches a rectangle of the master image, we
need to know the colors of both the tile images and rectangles in the
master image.</p>
<h4>Finding the Average Color of a Bitmap</h4>
<p>To find a matching tile image, we need to know the "color" of each tile.
One way would be to calculate the average color of each pixel in the
tile image by adding the red, green and blue values for each pixel and
dividing by the number of points.  For example, if we wanted the average
color of red <tt>(255, 0, 0)</tt> and blue <tt>(0, 0, 255)</tt> would
sum the colors to get <tt>(255, 0, 255)</tt>, and divide by 2 to get
<tt>(127.5, 0, 127.5)</tt>.  This looks kind of like purple, which is
what you might expect: <p></p>
<table cellpadding=10 cellspacing=10 align=center>
<tr>
<td bgcolor="#0000ff"><br><br></td><td></td>
<td bgcolor="#ff0000"></td><td></td>
<td bgcolor="#ff00ff"></td><td></td>
<td bgcolor="#770077"></td>
</td>
</tr>
<tr>
<td>
<code class="python">(255, 0, 0)</code>
</td>
<td><code class="python">+</code></td>
<td>
<code class="python">(0, 0, 255)</code>
</td>
<td><code class="python">=</code></td>
<td>
<code class="python">(255, 0, 255)</code>
</td>
<td><code class="python">/ 2 =</code></td>
<td>
<code class="python">(127.5, 0, 127.5)</code></td>
</tr>

</table>

<p>We can define a function that produces the sum of two colors by adding
the red, green and blue components separately (this is in <code>mosaic.py</code>):</p>
<pre class="brush: python;">
def add_color(color1, color2):
    """Returns a new color that is equal to the sum of the two input colors."""
    return make_color(
        get_red(color1) + get_red(color2),
        get_green(color1) + get_green(color2),
        get_blue(color1) + get_blue(color2))
</pre>

<p>To average many colors, we need to add all the colors together and
then divide by the number of colors.  One way to add a list of values
together is to divide it into two simpler problems: add the first
value to the sum of all the other values.   That is,
<pre>
SUM(a, b, c, d, e) = a + SUM(b, c, d, e) 
</pre></p>
<p>We can do the same thing for the remaining values:
<pre>
SUM(b, c, d, e) = b + SUM(c, d, e) 
   SUM(c, d, e) =     c + SUM(d, e)
      SUM(d, e) =         d + SUM(e)
         SUM(e) =             e + SUM()
          SUM() =                 0
</pre></p>
<p>The only tricky part is knowing what to do at the end when there are no
colors left.  We define the <tt>SUM</tt> of no values to be <tt>0</tt>.
Similarly, when there are no more colors left, we evaluate to the
<tt>0</tt>-color (black).</p>
<p>This is how we define <tt>sum_colors</tt> (in <code>mosaic.py</code>):</p>
<p><pre class="brush: python;">
def sum_colors(color_list):
    """"Returns a new color that is the sum of all the colors in the input list of colors."""
    if color_list is []:
        # If there are no colors to sum, return black. 
        return make_color(0, 0, 0)
    else:
        # Otherwise, add the first color in the list to the
    #  sum of the rest of the colors in the list.
        return add_color(color_list[0], sum_colors(color_list[1:]))
   </pre></p>
<p>To calculate the average color of a bitmap, we just calculate the sum
of all the colors of the pixels in the bitmap, and divide by the
number of pixels.</p>
<h3>Dividing the Master Image</h3>
<p>We need to divide the master image into tile-sized regions and calculate
the average color of each region. Our master image is a picture of the
Rotunda:  </p>
<p><center>
   <img src="static/images/rotunda.gif" width=512 height=378>
   </center> </p>
<p>(You may, of course, use any image you want as the master image, as long
as it is in the <code>.gif</code> format.  Ambitious students are encouraged to
use your own images to make more interesting photomosaics!)</p>
<p>We need to divide it up into tiles: </p>
<p><center>
   <img src="static/images/rotunda-divided.gif" width=512 height=378>
   </center> </p>
<p>The number of tiles is going horizontally across the image is equal to
the width of the master image divided by the width of each tile.  The
width of our original master Rotunda image is 1024 pixels, and the width
of each tile is 28 pixels. We can just divide to get the number of tiles
going horizontally:</p>
<pre class="brush: python;">
>>> ow = 1024   # width of original master Rotunda tile image
>>> tw = 28     # width of each tile
>>> ow / tw     # divide to get the number of horizontal tiles
36
</pre>

<p>Python has a handy function called <code class="python">range</code> that makes lists of numbers. </p>
<pre class="brush: python;">
>>> range(3) 
[0, 1, 2]               # first 3 natural numbers
>>> range(5) 
[0, 1, 2, 3, 4]         # first 5 natural numbers
</pre>

<p> 
If we want to iterate over a list of possible horizontal tiles, we just combine 
<code class="python">range</code> with our calculation from before:
</p>

<pre class="brush: python;">
>>> range(ow/tw)
[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35]
</pre>

<p>We then do the same thing vertically (based on the height of our original
master image and the height of each tiles). You can find the actual code for
this in <code>mosaic.py</code>, but you don't need to worry about it complete the 
assignment. </p>
<p>If you're curious and would like to get an intuition for it, here's very
similar similar code that makes a grid of nine tiles (like a Tic-Tac-Toe
board): </p>
<pre class="brush: python;">
for y in range(3):          # divide it up horizontally
    for x in range(3):      # and divide it up vertically
        print("(" + str(x) + "," + str(y) + ")    ", end="") 
    print("")               # start printing on the next line
</pre>

<p><pre class="brush: python;">
(0,0)     (1,0)     (2,0)
(0,1)     (1,1)     (2,1)
(0,2)     (1,2)     (2,2)
</pre> </p>
<p>We'll get into the details of how <code class="python keyword">for</code> works
soon, but it is not necessary to follow it now for this assignment.</p>
<h3>Selecting the Tiles</h3>
<p>We now know how to:</p>
<ol>
<li> Load the images 
<li> Calculate the average color of each tile by using <tt>add_color</tt> (and dividing the total)
<li> Divide the master image into tile size regions 
</ol>

<p>Suppose we know how to find the best tile for one region.  All we need
to do make the whole photomosaic is do that for every region of the master
image. It might look roughtly like this: </p>
<pre class="brush: python;">
for sample_region in regions_of_original_master_image:
    sample_average_color = average_color_of(sample_region)
    best_tile = find_best_match(sample_average_color, all_tiles) 
    paste_onto_photomosaic(best_tile)
</pre>

<p>The real heart of the action is <code
class="python">find_best_match</code>, which will return the tile that
best matches the color of a sample region of the master image.</p>
<p>Here's how it works:</p>
<ol>
        <li> If there is only one tile available, it must be the best match 
                (it's also the only match, but it's the best match).
        <li> If there are exactly two tiles available, we pick whichever
                tile is a <code class="python">closer_color</code> to the desired sample. 
                We haven't written a <code class="python">closer_color</code> procedure
                yet, but you will do that later.
        <li> If there are three or more tiles available, we use divide and 
                conquer. Suppose there are <i>N</i> tiles. We set
                aside one tile so that there are <i>N</i> - 1 left. Then
                we call <tt>find_best_match</tt> on those <i>N</i> - 1
                tiles. So now we have our set-aside tile and the best
                match of the <i>N</i> - 1 remaining tiles. But that's just two tiles, so
                we pick whichever tile is a <code class="python">closer_color</code> to the 
                desired sample.
</ol>

<p>Here's a visual representation: 
<center>
<img src="static/images/find-best-match.png">
</center> </p>
<p>At the top we see our sample region (blue sky with part of a tree) and its 
average color (light blue). We also have three tiles in this example:
tile (a) is brown, tile (b) is dark blue, and tile (c) is green. 
<ol>
<li>
If we are asked to find the best match between the blue sample tile
and <i>only the green tile is available</i>, then the green tile must be our
answer.
<li>
If we are asked to find the best match between the blue sample tile
and <i>two tiles, dark blue and green, are available</i>, then we 
figure out that dark blue is a <code class="python">closer_color</code> to light blue
than is green, so we return the dark blue tile.
<li>
If we are asked to find the best match between <i>all three tiles</i>,
we first set the brown tile aside. Now we're left with just the dark
blue and the green tiles, and we call <code class="python">find_best_match</code> on them.
But we already know what that answer is (it was in the previous paragraph):
the best match there is the dark blue tile. So now we just have the brown tile 
and the dark blue tile. We again use <code class="python">closer_color</code> and determine
that dark blue is closer to light blue than is brown. So we finally return the 
dark blue tile. 
</ol> 
So that's how <code class="python">find_best_match</code> works. Below is the Python 
code that implements <code class="python">find_best_match</code>. You should read it carefully,
but do not worry if it doesn't make perfect sense yet.</p>
<p><pre class="brush: python;">
def find_best_match(sample_color, tiles, tile_colors, closer_color):
    """
    Given a sample color, returns the tile image that is closest to
    that sample color according to closer_color.
    """
    if tiles is []:
        print("Error: no tiles to match?")
        return None
    elif len(tiles) is 1:
        # There is only one tile, so it must be the best match.
        return [tiles[0], tile_colors[0]]
    else:
        # We'll "set aside" the first tile and call it "a". 
        [a_tile, a_color] = [tiles[0], tile_colors[0]]
                      #
        # Now we call find_best_match recursively on all of the tiles we didn't set aside.
        [b_tile, b_color] = find_best_match(sample_color, tiles[1:], 
                                            tile_colors[1:], closer_color)
        # So now we have the set-aside a_tile and the b_tile, the best of the other tiles.
        # We just use closer_color to pick between them!
        if closer_color(sample_color, a_color, b_color):
            return [a_tile, a_color]
        else:
            return [b_tile, b_color]
   </pre> </p>
<p>If you look carefully, you can see that we've folded the "two tiles case"
and the "three or more tiles case" into one giant "two or more tiles case".</p>
<h3>Loading the Tiles and Master</h3>
<p>We still need to figure out how to create the list of tiles.  Suppose
we start with a list of filenames of images and want to turn that into
a list of bitmaps to use as the tiles.  How can we break that into
simpler problems? </p>
<p>If we have a function that can load one tile image, then all we need
to do is apply that function to every filename in the list of image
filenames.</p>
<p>Python provides a very expressive way of doing all this in just one line
(don't worry about understanding it now):</p>
<pre class="brush: python;">
    tile_images = [Image(Point(0, 0), fname) for fname in tile_files]
</pre>

<p>Now, all we need are ways of getting a list of image filenames and for
loading one image.  We could just create the list of images by hand, but
for a good photomosaic we need many images.  So, we instead put all the
tile images in a directory and use a function that gets a list of all
files in a directory.  Python provides <code class="python">glob</code>
(yes, the name is funny!) to do that. The actual code provided is a bit
more complicated: we want the name of the directory of images to be a
parameter, and we only want to load <code class="python">.GIF</code>
images (a particular image compression format):
<pre class="brush: python;">
    tile_files = glob.glob(tile_directory + "/*.gif")
</pre></p>
<h3>Putting Everything Together</h3>
<p>We need to combine all the steps now into one procedure that produces a
photomosaic.  Here is pseudocode that does so:</p>
<pre class="brush: python;">
def make_photomosaic(original_filename, tile_directory, closer_color):

    # Load the original master image (e.g., the Rotunda)
    original = load_one_image(original_filename)

    # Find all of the names of all of the tile files 
    tile_filenames = glob(tile_directory, ".GIF") 

    # Load all of the tile images 
    tile_images = load_many_images(tile_filenames) 

    # For each tile image, find its average color. 
    tile_colors = map(image_average_color, tile_images) 

    # Consider a grid over the original master image
    for y in range(number_of_vertical_tiles):
        for x in range(number_of_horizontal_tiles):
            # For each grid position (x,y) ...

            # Look at just the sample in this grid position
            sample_region = get_part_of_image(original, x, y)

            # Compute its average color
            sample_color = image_average_color(sample_region)

            # Find the best match for this grid's color
            # from among all the tiles we have! 
            best_tile = find_best_match(sample_color, tile_images, tile_colors, closer_color)

            # Paste the best tile over this grid position.  
            draw(best_tile, x, y) 
</pre>

<p>That's it! You can find the full code in <code>mosaic.py</code> &mdash; it includes
extra details, such as the grid size calculation, but you've seen all of
the key concepts.</p>
<h3>Matching Colors</h3>
<p>We're all done now, except for the procedure that determines which of
two colors is a better match for another color.  That is left for you to
do!</p>
<div class=q>
<b>Question 5:</b> 
Write a function <code class="python">closer_color</code> that can be passed in
to <code class="python">make_photomosaic</code>. Define your function in the 
same Python file you used for Questions 3 and 4.
</div>

<p>Your function should look like
<pre class="brush: python;">
def closer_color(sample, color1, color2):
    # Fill in with code that returns True if sample is closer to color1
    # than it is to color2. Return False otherwise. 
</pre></p>
<p>In addition to the standard arithmetic operators (<code
class="python">+</code>, <code class="python">*</code>, <code
class="python">-</code>, <code class="python">/</code>), comparison
operators (<code class="python">&lt;</code>, <code
class="python">&gt;</code>, <code class="python">=</code>), provided
procedures for manipulating colors (<code class="python">get_red</code>,
<code class="python">get_green</code> and <code
class="python">get_blue</code>), some other procedures you may find
useful include:</p>
<ul>
<li><code class="python">abs(<em>number</em>)</code> &#151; evaluates to the absolute value of
number parameter.  For example, <code class="python">abs(-3) == 3</code>.

<li><code class="python">sqrt(<em>number</em>)</code> &#151; evaluates to an approximation of
the square root of the number parameter.  For example, <code class="python">sqrt(2) ==
1.4142135623730951</code>.

<li><code class="python">pow(<em>number</em>,<em>exponent</em>)</code> &mdash; raises
the number to the given power. For example, <code class="python">pow(7,2) == 49</code>
(i.e., 7 squared is 49). 

</ul>

<p>Before trying to use it to make a photomosaic, you should test out your
<code class="python">closer-color</code> procedure using some simple
colors:</p>
<pre class="brush: python;">
>>> closer_color(WHITE, WHITE, BLACK)
True    # white is closer to white than to black
>>> closer_color(WHITE, BLACK, WHITE)
False   # white not not closer to black than to white
>>> closer_color(RED, ORANGE, BLUE)
True    # red is closer to orange than to blue
</pre>

<p>Once your <code class="python">closer_color</code> procedure works for the simple examples, 
try making a photomosaic by uncommenting this line at
the bottom of the provided <code class="python">turnin.py</code> file:<br />
<pre class="brush: python;">
make_photomosaic("rotunda.gif", "tiles/", closer_color) 
</pre> 
You can also pass in another <code class="python">.gif</code> image instead of
<code class="python">"rotunda.gif"</code> if you have one. 
<p> 
If your <code class="python">closer_color</code> procedure is good,
you should be able to recognize the rotunda when you 
see the photomosaic. </p>
<p>Experiment with different ways of deciding which two colors are closest
to improve your photomosaic, but try simple things first.  A good <code
class="python">closer_color</code> procedure should produce a
delightful photomosaic!</p>
<p><div class="turnin"> 
Print out your <code>turnin.py</code> file (see below for a good way to print out a Python file) and make sure to
remember to write your UVA ID on it in ridicously large block letters so
even a bleary-eyed professor can read it.  If your printout involves
multiple pages, please <b>securely staple</b> them. Ad hoc taping jobs,
paper clips, and loose pages all come apart when all of the assignments
are put in a pile. The course staff charges extravagant fees for any of
our own gold-plated and diamond-encrusted staples we need to use to bind
your assignments.<br />
   </div></p>
<p><strong>Printing Python Files.</strong>  A good way to print out your python file is to use pygments:</p>
<p><code>pip install Pygments</code></p>
<p>Then, to print out <code>turnin.py</code>, in the directory that contains your <code>turnin.py</code> file, run</p>
<p><code>pygmentize -O full,style=emacs -o turnin.html turnin.py</code></p>
<p>Then, click on <code>turnin.html</code> to open it in a web browser and print from the browser.</p>
<h4>Teasers</h4>
<p>Mosaics touch on many computer science issues, some of which we will
return to later in the course.</p>
<p><b>Higher Order Functions.</b> We used <code class="python">map</code> to apply a function
to every element of a list.  <code class="python">map</code> is an example of a <em>higher
order function</em> &#151; that means it is a function that takes other
functions as parameters.  Higher order functions can be very powerful.
In Problem Set 2 (and throughout the course), we will explore higher
order functions and recursion.</p>
<p><b>Lists.</b> Many functions in this assignment operated on
<em>lists</em>.  In Problem Set 2, you will understand lists and
implement functions that operate on lists (for example, you will be able
to implement <code class="python">map</code>).</p>
<p><b>Computational Complexity.</b> Our program might use the same tile
image over and over again.  If there is a large section of the same
color in our master image, the same tile image will be repeated for that
whole section.  This looks pretty bad.  A real mosaic would never reuse
the same tile.  Producing a non-duplicating photomosaic is an extremely
hard problem.  In fact, it is such a hard problem that no one knows for
sure whether or not there is a <em>fast</em> solution (we'll explain
exactly what we mean by fast here later in the course) to finding the
best photomosaic tiling.  Computer scientists call this an
<em>NP-hard</em> problem.  If someone discovers a fast way to produce
the best possible non-repeating photomosaic, then it means there are
also fast solutions to many other seemingly unrelated and important
problems (such as the "travelling salesperson problem" where the goal is
to find the best route for a salesperson to visit a set of cities, and
the "cure most deadly diseases problem" where the goal is to find a
sequence of proteins that folds into a particular shape).  We will
explore this about halfway through the course.</p>
<p><b>Searching.</b> Our program takes a long time to run for even small
photomosaics.  A really smart kindergartner wouldn't find a good match
by looking through all the images scattered haphazardly on the floor;
instead, she would sort the images into groups based on their color.
Then she could easily see all the bluish images together, and pick the
one that best matches a particular square.  Our program has to consider
every image for every rectangle.  A better program would be able to
quickly find the best image without having to consider every image every
time.  Computer scientists do a lot of work on finding better ways to
search (the main focus of Lesson 5 in the Udacity cs101 course).</p>
<p><b>Concurrency.</b> One thing to note about our problem division
solution, is that some of the steps can be done in different orders, but
others can only be done after an earlier step is already complete.  For
example, we can do steps 3, 4 and 5 before step 1, but we cannot do step
7 before step 1.  If we have a whole class of kindergartners to help
make our photomosaic, we could give each of them a magazine and have
them all collect tile pictures at the same time.  One way to make
computers solve a problem quicker is to divide the problem into pieces
that can be done at the same time, and have different computers work on
each piece at the same time.</p>
<p><b>Photomosaic-mosaics.</b> A photomosaic is a mosaic made with photo
tiles.  We could also make a <em>photomosaic-mosaic</em>, a mosaic made
with photomosaic tiles.  Of course, why stop there?  We could make a
<em>photomosaic-mosaic-mosaic</em>, a mosaic where the tiles are
photomosaic-mosaics.  If we have a lot of computing power, we could make
a <em>photomosaic-movie</em>, a movie where the frames are photomosaics,
or a <em>moviemosaic-photo</em>, a still image where the tiles are
movies instead of still images. The
<a href="http://www.youtube.com/watch?v=4eLCc1hxUfU">introduction to the
1998 World Cup</a> features a 
<em>moviemosaic-movie</em>
(or perhaps more accurately, <em>moviemosaic-mosaic-mosaic-movie</em>)
that has been seen by several billion people!  </p>
<p><b>Software Patents.</b> Robert Silvers claims to have a patent (<a
href="http://www.google.com/patents?vid=USPAT6137498">United
States Patent 6,137,498: Digital composition of a mosaic image</a>) on
Photomosaics.  We're not sure what the ancient Babylonians have to say
about this, but software patents raise lots of complex legal issues.
One would have to check with a lawyer to determine if you can
redistribute your code from this problem set, but we encourage you to do
so and would be happy to defend a test case against this patent.</p>
<p><div class="credits">
<b>Credits:</b> This problem set was originally developed for UVA CS200
way back in Spring 2002 by David Evans and revised for Spring 2003 by David Evans,
Spencer Stockdale and Katie Winstanley.  It was adapted for Python by Westley Weimer for Fall 2012, and
revised for Spring 2016 by David&nbsp;Evans and Yuchi Tian.
   </div></p></div>
    </div>
    <div id="footer">
<a href="index.html">University of Virginia - cs1120</a>
<span class="right">
<a href="http://www.cs.virginia.edu/evans/">David Evans</span>
</div>
  </body>

<!-- Mirrored from xplorecs.org/project1 by HTTrack Website Copier/3.x [XR&CO'2014], Fri, 26 Aug 2022 17:11:59 GMT -->
</html>